# アーキテクチャ概要

## 概要

このドキュメントは、プロジェクト全体のアーキテクチャの要点、リスク、改善案をまとめた統合レポートです。

## 1. プロジェクト構造

### 1.1 主要コンポーネント

プロジェクトは以下の4つの主要コンポーネントで構成されています：

1. **Editor（エディタ）**
   - クイズの作成・編集機能
   - 診断質問の評価軸設定
   - プロジェクトの保存・読み込み

2. **Player（プレイヤー）**
   - クイズの実行
   - Glossary自動提示
   - 学習ログの記録

3. **Admin（管理）**
   - プロジェクト管理
   - バージョン管理
   - プロジェクト本棚UI

4. **Analysis（分析）**
   - 学習データの分析
   - 可視化
   - クラスタリング

### 1.2 コアモジュール

- **config.js**: プロジェクト設定の読み込み・保存
- **GlossaryLoader.js**: 3層構造のGlossary読み込み・統合
- **dataset_loader.js**: 学習データセットの読み込み

## 2. 依存関係の要点

### 2.1 モジュール依存関係

```
Editor → config.js, GlossaryLoader.js, pin.js
Player → config.js, GlossaryLoader.js, logging.js, recommendation.js
Admin → pin.js, dataset_loader.js, analysis.js
Analysis → dataset_loader.js, vector_math.js, Chart.js
Glossary → config.js, GlossaryLoader.js, pin.js
```

### 2.2 データ依存関係

```
projects/project.json → config.js → 全コンポーネント
projects/quiz.json → editor.js, player.js, analysis.js
projects/glossary.json → GlossaryLoader.js → editor.js, player.js
students/index.json → dataset_loader.js → analysis.js
students/*_logs.json → dataset_loader.js → analysis.js
```

### 2.3 localStorage依存関係

```
localStorage.projects → editor.js, player.js
localStorage.editor_current_project → editor.js
localStorage.autosave_project → editor.js
localStorage.currentGlossary → editor.js
localStorage.projectId → 全コンポーネント
```

## 3. リスク分析

### 3.1 循環依存のリスク

#### 低リスク
- **Editor ↔ Glossary**: GlossaryLoaderが独立モジュールのため、循環依存なし
- **Editor ↔ Player**: localStorageを共有しているが、直接的な依存関係なし

#### 中リスク
- **グローバル変数の使用**: `window.currentGlossary` などのグローバル変数が複数のコンポーネントで使用されている
  - **影響**: 変数の更新タイミングによっては不整合が発生する可能性
  - **対策**: イベント駆動アーキテクチャへの移行を推奨

### 3.2 localStorageとの不整合リスク

#### 高リスク
1. **ファイルシステムとlocalStorageの不整合**
   - `localStorage.projects` に存在するが、実際のファイルが削除されている
   - **影響**: プロジェクト一覧に表示されるが、読み込み時にエラー
   - **対策**: ファイル存在確認を追加

2. **複数タブ間の同期問題**
   - 複数のタブで同時に編集した場合、localStorageの更新が競合する可能性
   - **影響**: データの上書きや不整合
   - **対策**: `storage` イベントで同期処理を追加

#### 中リスク
1. **localStorageの容量制限**
   - ブラウザによって5MB〜10MBの制限
   - **影響**: 大量のプロジェクトやログデータで容量不足
   - **対策**: IndexedDBへの移行を検討

### 3.3 データ整合性のリスク

#### 高リスク
1. **Glossary用語IDの重複**
   - 複数のGlossaryで同じIDの用語が定義されている場合、後勝ちで上書き
   - **影響**: 予期しない用語が使用される
   - **対策**: 用語IDの一意性チェックを追加

2. **クイズバージョンの不整合**
   - `quiz.json` と `quiz_versions/latest.json` の不一致
   - **影響**: バージョン管理の不整合
   - **対策**: バージョン管理システムで整合性保証

#### 中リスク
1. **プロジェクトIDの一貫性**
   - `localStorage.projectId` と実際のプロジェクトフォルダ名の不一致
   - **影響**: プロジェクト読み込み失敗
   - **対策**: プロジェクトIDの検証を追加

### 3.4 パフォーマンスリスク

#### 中リスク
1. **大量データの読み込み**
   - `students/*_logs.json` が大きい場合、読み込みに時間がかかる
   - **影響**: UIのフリーズ
   - **対策**: ストリーミング読み込みやページネーションの実装

2. **Glossaryの統合処理**
   - 複数のGlossaryファイルを読み込んで統合する処理が重い
   - **影響**: 初回読み込みが遅い
   - **対策**: キャッシュ機能の追加

## 4. 改善案

### 4.1 アーキテクチャの改善

#### 4.1.1 モジュール化の推進

**現状**: グローバル変数とIIFE（即時実行関数）によるモジュール化

**改善案**:
- ES6モジュール（`import`/`export`）への移行
- モジュールバンドラー（Webpack, Vite等）の導入
- 依存関係の明示化

**メリット**:
- 循環依存の検出が容易
- 型安全性の向上（TypeScript導入時）
- バンドルサイズの最適化

#### 4.1.2 状態管理の統一

**現状**: 各コンポーネントが独自に状態管理

**改善案**:
- 状態管理ライブラリ（Redux, Zustand等）の導入
- グローバル状態とローカル状態の分離
- イベント駆動アーキテクチャの採用

**メリット**:
- 状態の一貫性保証
- デバッグの容易化
- テストの容易化

#### 4.1.3 データレイヤーの抽象化

**現状**: 各コンポーネントが直接ファイルシステムやlocalStorageにアクセス

**改善案**:
- データアクセス層（Data Access Layer）の導入
- リポジトリパターンの採用
- キャッシュ層の追加

**メリット**:
- データソースの変更が容易（ファイルシステム → API等）
- キャッシュ戦略の統一
- エラーハンドリングの統一

### 4.2 データ管理の改善

#### 4.2.1 データバリデーションの強化

**現状**: 最小限のバリデーション

**改善案**:
- JSON Schemaによるスキーマ検証
- ランタイム型チェック（Zod, Yup等）
- データ整合性チェックの自動化

**メリット**:
- データ不整合の早期発見
- エラーメッセージの改善
- 開発効率の向上

#### 4.2.2 ストレージ戦略の最適化

**現状**: localStorage中心のストレージ

**改善案**:
- IndexedDBへの移行（大量データ対応）
- サーバーサイドストレージの検討（将来）
- キャッシュ戦略の最適化

**メリット**:
- 容量制限の緩和
- パフォーマンスの向上
- オフライン対応の強化

#### 4.2.3 データ同期の改善

**現状**: 手動での同期

**改善案**:
- 自動同期機能の実装
- 競合解決の仕組み
- バージョン管理の強化

**メリット**:
- データの一貫性保証
- ユーザー体験の向上
- データ損失の防止

### 4.3 UI/UXの改善

#### 4.3.1 ルーティングシステムの導入

**現状**: HTMLファイル間の直接リンク

**改善案**:
- SPA（Single Page Application）化
- ルーティングライブラリの導入
- 深いリンクのサポート

**メリット**:
- ページ遷移の高速化
- URLによる状態管理
- ブラウザ履歴との連携

#### 4.3.2 コンポーネント化の推進

**現状**: 各ページが独立したHTMLファイル

**改善案**:
- Web Componentsの採用
- コンポーネントライブラリの導入
- 再利用可能なUIコンポーネントの作成

**メリット**:
- コードの再利用性向上
- 保守性の向上
- 一貫性のあるUI

### 4.4 パフォーマンスの改善

#### 4.4.1 遅延読み込みの実装

**現状**: すべてのデータを一度に読み込み

**改善案**:
- コード分割（Code Splitting）
- 遅延読み込み（Lazy Loading）
- 仮想スクロールの導入

**メリット**:
- 初回読み込み時間の短縮
- メモリ使用量の削減
- ユーザー体験の向上

#### 4.4.2 キャッシュ戦略の最適化

**現状**: 最小限のキャッシュ

**改善案**:
- Service Workerの導入
- HTTPキャッシュの活用
- インメモリキャッシュの実装

**メリット**:
- 読み込み速度の向上
- ネットワーク負荷の軽減
- オフライン対応の強化

## 5. 技術的負債

### 5.1 既知の技術的負債

1. **レガシーコードの残存**
   - `legacy/` フォルダに大量のレガシーコード
   - **影響**: コードベースの複雑化
   - **対策**: 段階的なリファクタリング

2. **グローバル変数の多用**
   - `window.*` 変数が多数使用されている
   - **影響**: 名前空間の汚染、デバッグの困難
   - **対策**: モジュール化の推進

3. **エラーハンドリングの不足**
   - 一部の処理でエラーハンドリングが不十分
   - **影響**: 予期しないエラー時の動作が不安定
   - **対策**: 統一的なエラーハンドリングの実装

### 5.2 優先度の高い改善項目

1. **データバリデーションの強化**（高優先度）
   - データ不整合のリスクが高い
   - 実装コストが比較的低い

2. **localStorageとファイルシステムの同期**（高優先度）
   - ユーザー体験に直接影響
   - データ損失のリスク

3. **モジュール化の推進**（中優先度）
   - 長期的な保守性向上
   - 実装コストが高い

## 6. セキュリティ考慮事項

### 6.1 現在のセキュリティ対策

1. **PIN認証**
   - `src/admin/pin.js` でPIN認証を実装
   - 管理者機能へのアクセス制御

2. **CORS対策**
   - 同一オリジンポリシーに依存
   - 外部リソースの読み込み制限

### 6.2 推奨される改善

1. **入力値のサニタイズ**
   - XSS（Cross-Site Scripting）対策
   - HTMLエスケープの徹底

2. **ファイルアップロードの検証**
   - ファイルタイプの検証
   - ファイルサイズの制限

3. **認証の強化**
   - セッション管理の改善
   - トークンベース認証の検討

## 7. テスト戦略

### 7.1 現在のテスト状況

- テストファイルが存在しない
- 手動テストに依存

### 7.2 推奨されるテスト戦略

1. **単体テスト**
   - 各モジュールの単体テスト
   - Jest, Vitest等のテストフレームワークの導入

2. **統合テスト**
   - コンポーネント間の連携テスト
   - E2Eテスト（Playwright, Cypress等）

3. **データ整合性テスト**
   - データバリデーションのテスト
   - スキーマ検証のテスト

## 8. ドキュメント整備

### 8.1 現在のドキュメント

- `docs/architecture/` - アーキテクチャドキュメント（本ドキュメント）
- `docs/glossary_spec.md` - Glossary仕様
- `docs/diagnostic_logic.md` - 診断ロジック仕様
- `README.md` - プロジェクト概要

### 8.2 推奨される追加ドキュメント

1. **APIドキュメント**
   - 各モジュールのAPI仕様
   - JSDocコメントの充実

2. **開発者ガイド**
   - 開発環境のセットアップ
   - コーディング規約
   - コントリビューションガイド

3. **ユーザーガイド**
   - エディタの使い方
   - プレイヤーの使い方
   - よくある質問（FAQ）

## 9. まとめ

### 9.1 アーキテクチャの強み

1. **明確な責務分離**
   - Editor, Player, Admin, Analysisの4つの主要コンポーネントが明確に分離
   - 各コンポーネントが独立して動作可能

2. **柔軟なデータ構造**
   - JSONベースのデータ構造で拡張性が高い
   - プロジェクトごとに独立したデータ管理

3. **3層構造のGlossary**
   - Global/Domain/Projectの3層構造で柔軟な用語管理

### 9.2 改善が必要な領域

1. **モジュール化**
   - グローバル変数の削減
   - ES6モジュールへの移行

2. **データ整合性**
   - バリデーションの強化
   - 同期処理の改善

3. **パフォーマンス**
   - 遅延読み込みの実装
   - キャッシュ戦略の最適化

### 9.3 次のステップ

1. **短期（1-2ヶ月）**
   - データバリデーションの強化
   - localStorageとファイルシステムの同期改善
   - エラーハンドリングの統一

2. **中期（3-6ヶ月）**
   - モジュール化の推進
   - テストフレームワークの導入
   - パフォーマンス最適化

3. **長期（6ヶ月以上）**
   - SPA化の検討
   - サーバーサイドAPIの導入
   - マイクロフロントエンドアーキテクチャの検討

## 10. 参考資料

- [依存関係マップ](./dependency_map.md) - 詳細な依存関係
- [データフロー図](./data_flow.md) - データの流れ
- [UI遷移図](./ui_routes.md) - UI遷移の詳細

